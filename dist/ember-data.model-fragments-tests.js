module('JSHint - jshint/ember-data/lib');
test('jshint/ember-data/lib/main.js should pass jshint', function() { 
  ok(true, 'jshint/ember-data/lib/main.js should pass jshint.'); 
});

module('JSHint - jshint/ember-data/lib/system');
test('jshint/ember-data/lib/system/model.js should pass jshint', function() { 
  ok(true, 'jshint/ember-data/lib/system/model.js should pass jshint.'); 
});

module('JSHint - jshint/ember-data/lib/system/model');
test('jshint/ember-data/lib/system/model/states.js should pass jshint', function() { 
  ok(true, 'jshint/ember-data/lib/system/model/states.js should pass jshint.'); 
});

module('JSHint - jshint/ember-data/lib/system');
test('jshint/ember-data/lib/system/snapshot.js should pass jshint', function() { 
  ok(true, 'jshint/ember-data/lib/system/snapshot.js should pass jshint.'); 
});

module('JSHint - jshint/ember-data/lib/system');
test('jshint/ember-data/lib/system/store.js should pass jshint', function() { 
  ok(true, 'jshint/ember-data/lib/system/store.js should pass jshint.'); 
});

module('JSHint - jshint/ember-data/lib/system');
test('jshint/ember-data/lib/system/transform.js should pass jshint', function() { 
  ok(true, 'jshint/ember-data/lib/system/transform.js should pass jshint.'); 
});

module('JSHint - jshint/ember/lib');
test('jshint/ember/lib/main.js should pass jshint', function() { 
  ok(true, 'jshint/ember/lib/main.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib');
test('jshint/model-fragments/lib/core-model.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/core-model.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/fragments/array');
test('jshint/model-fragments/lib/fragments/array/fragment.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/fragments/array/fragment.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/fragments/array');
test('jshint/model-fragments/lib/fragments/array/stateful.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/fragments/array/stateful.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/fragments');
test('jshint/model-fragments/lib/fragments/attributes.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/fragments/attributes.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/fragments');
test('jshint/model-fragments/lib/fragments/ext.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/fragments/ext.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/fragments');
test('jshint/model-fragments/lib/fragments/model.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/fragments/model.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/fragments');
test('jshint/model-fragments/lib/fragments/states.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/fragments/states.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/fragments');
test('jshint/model-fragments/lib/fragments/transform.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/fragments/transform.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib');
test('jshint/model-fragments/lib/initializers.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/initializers.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib');
test('jshint/model-fragments/lib/main.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/main.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/lib/util');
test('jshint/model-fragments/lib/util/ember-new-computed.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/lib/util/ember-new-computed.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/integration/fragments');
test('jshint/model-fragments/tests/integration/fragments/dependent_state_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/integration/fragments/dependent_state_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/integration/fragments');
test('jshint/model-fragments/tests/integration/fragments/nested_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/integration/fragments/nested_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/integration/fragments');
test('jshint/model-fragments/tests/integration/fragments/save_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/integration/fragments/save_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/unit');
test('jshint/model-fragments/tests/unit/fragment_array_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/unit/fragment_array_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/unit');
test('jshint/model-fragments/tests/unit/fragment_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/unit/fragment_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/unit/fragments');
test('jshint/model-fragments/tests/unit/fragments/has_many_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/unit/fragments/has_many_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/unit/fragments');
test('jshint/model-fragments/tests/unit/fragments/has_one_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/unit/fragments/has_one_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/unit/fragments');
test('jshint/model-fragments/tests/unit/fragments/owner_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/unit/fragments/owner_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/unit');
test('jshint/model-fragments/tests/unit/polymorphic_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/unit/polymorphic_test.js should pass jshint.'); 
});

module('JSHint - jshint/model-fragments/tests/unit');
test('jshint/model-fragments/tests/unit/store_test.js should pass jshint', function() { 
  ok(true, 'jshint/model-fragments/tests/unit/store_test.js should pass jshint.'); 
});

define(
  "model-fragments/tests/integration/fragments/dependent_state_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var store, Person, Name, Address, people;

    module("integration/fragments - Dependent State", {
      setup: function() {
        Person = DS.Model.extend({
          title     : DS.attr("string"),
          name      : DS.hasOneFragment("name"),
          addresses : DS.hasManyFragments("address"),
          titles    : DS.hasManyFragments()
        });

        Name = DS.ModelFragment.extend({
          first : DS.attr("string"),
          last  : DS.attr("string")
        });

        Address = DS.ModelFragment.extend({
          street  : DS.attr("string"),
          city    : DS.attr("string"),
          region  : DS.attr("string"),
          country : DS.attr("string")
        });

        store = createStore({
          person: Person,
          address: Address,
          name: Name
        });

        people = [
          {
            id: 1,
            name: {
              first: "Tyrion",
              last: "Lannister"
            },
            addresses: [
              {
                street: "1 Sky Cell",
                city: "Eyre",
                region: "Vale of Arryn",
                country: "Westeros"
              },
              {
                street: "1 Tower of the Hand",
                city: "King's Landing",
                region: "Crownlands",
                country: "Westeros"
              }
            ],
            titles: [
              "Hand of the King",
              "Master of Coin"
            ]
          }
        ];
      },

      teardown: function() {
        store = null;
        Person = null;
        Address = null;
        Name = null;
        people = null;
      }
    });

    function pushPerson(id) {
      store.push('person', Ember.copy(Ember.A(people).findBy('id', id), true));
    }

    test("changing a `DS.hasOneFragment` fragment property dirties the fragment and owner record", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Jamie",
          last: "Lannister"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        name.set('first', 'Cercei');

        ok(name.get('isDirty'), "fragment is dirty");
        ok(person.get('isDirty'), "owner record is dirty");
      });
    });

    test("restoring a `DS.hasOneFragment` fragment to its original state returns the fragment and owner record to a clean state", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Hoster",
          last: "Tully"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        name.set('first', 'Brynden');
        name.set('first', 'Hoster');

        ok(!name.get('isDirty'), "fragment is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("restoring a `DS.hasOneFragment` fragment to its original state when the owner record was dirty returns the fragment to a clean state maintains the owner record's dirty state", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Jorah",
          last: "Mormont"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        // Dirty the owner record
        person.set('title', 'Lord Commander');

        name.set('first', 'Jeor');
        name.set('first', 'Jorah');

        ok(!name.get('isDirty'), "fragment is clean");
        ok(person.get('isDirty'), "owner record is still dirty");
      });
    });

    test("rolling back the owner record returns a `DS.hasOneFragment` fragment and owner record to a clean state", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Catelyn",
          last: "Stark"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        name.set('last', 'Tully');

        person.rollback();

        ok(!name.get('isDirty'), "fragment is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("a record can be rolled back multiple times", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Arya",
          last: "Stark"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        name.set('last', '');
        person.rollback();

        equal(name.get('last'), 'Stark', "fragment has correct values");
        ok(!name.get('isDirty'), "fragment is clean");
        ok(!person.get('isDirty'), "owner record is clean");

        name.set('last', '');
        person.rollback();

        equal(name.get('last'), 'Stark', "fragment has correct values");
        ok(!name.get('isDirty'), "fragment is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("rolling back a `DS.hasOneFragment` fragment returns the fragment and the owner record to a clean state", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Sansa",
          last: "Stark"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        // Dirty the fragment
        name.set('last', 'Lannister');

        name.rollback();

        ok(!name.get('isDirty'), "fragment is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("rolling back a `DS.hasOneFragment` fragment when the owner record is dirty returns the fragment to a clean state and maintains the owner record's dirty state", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Sansa",
          last: "Stark"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        // Dirty the owner record and fragment
        person.set('title', 'Heir to Winterfell');
        name.set('last', 'Lannister');

        name.rollback();

        ok(!name.get('isDirty'), "fragment is clean");
        ok(person.get('isDirty'), "owner record is still dirty");
      });
    });

    test("a `DS.hasOneFragment` fragment property that is set to null can be rolled back", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        person.set('name', null);

        ok(person.get('isDirty'), "owner record is dirty");

        person.rollback();

        deepEqual(person.get('name'), name, "property is restored");
        ok(!name.get('isDirty'), "fragment is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("a `DS.hasOneFragment` fragment property that is null can be rolled back", function() {
      store.push('person', { id: 1, });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        equal(name, null, "property is null");

        person.set('name', store.createFragment('name', { first: 'Rob', last: 'Stark' }));

        ok(person.get('isDirty'), "owner record is dirty");

        person.rollback();

        equal(person.get('name'), null, "property is null again");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("adding a fragment to a fragment array dirties the fragment array and owner record", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        addresses.createFragment('address', {
          street: "1 Dungeon Cell",
          city: "King's Landing",
          region: "Crownlands",
          country: "Westeros"
        });

        ok(addresses.get('isDirty'), "fragment array is dirty");
        ok(person.get('isDirty'), "owner record is dirty");
      });
    });

    test("removing a fragment from a fragment array dirties the fragment array and owner record", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        addresses.removeObject(addresses.get('firstObject'));

        ok(addresses.get('isDirty'), "fragment array is dirty");
        ok(person.get('isDirty'), "owner record is dirty");
      });
    });

    test("reordering a fragment array dirties the fragment array and owner record", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var length = addresses.get('length');

        var address = addresses.popObject();
        addresses.unshiftObject(address);

        equal(addresses.get('length'), length, "fragment array length is maintained");
        ok(addresses.get('isDirty'), "fragment array is dirty");
        ok(person.get('isDirty'), "owner record is dirty");
      });
    });

    test("restoring a fragment array to its original order returns the fragment array owner record to a clean state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        var address = addresses.popObject();
        addresses.pushObject(address);

        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("restoring a fragment array to its original order when the owner record was dirty returns the fragment array to a clean state and maintains the owner record's dirty state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        // Dirty the owner record
        person.set('title', 'Hand of the King');

        var address = addresses.popObject();
        addresses.pushObject(address);

        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(person.get('isDirty'), "owner record is still dirty");
      });
    });

    test("changing a `DS.hasManyFragments` fragment property dirties the fragment, fragment array, and owner record", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        address.set('street', '2 Sky Cell');

        ok(address.get('isDirty'), "fragment is dirty");
        ok(addresses.get('isDirty'), "fragment array is dirty");
        ok(person.get('isDirty'), "owner record is dirty");
      });
    });

    test("restoring a `DS.hasManyFragments` fragment to its original state returns the fragment, fragment array, and owner record to a clean state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        address.set('street', '2 Sky Cell');
        address.set('street', '1 Sky Cell');

        ok(!address.get('isDirty'), "fragment is clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("restoring a `DS.hasManyFragments` fragment to its original state when the fragment array was dirty returns the fragment to a clean state and maintains the fragment array and owner record's dirty state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        // Dirty the record array
        addresses.popObject();

        address.set('street', '2 Sky Cell');
        address.set('street', '1 Sky Cell');

        ok(!address.get('isDirty'), "fragment is clean");
        ok(addresses.get('isDirty'), "fragment array is still dirty");
        ok(person.get('isDirty'), "owner record is dirty");
      });
    });

    test("restoring a `DS.hasManyFragments` fragment to its original state when the owner record was dirty returns the fragment and fragment array to a clean state maintains the owner record's dirty state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        address.set('street', '2 Sky Cell');
        address.set('street', '1 Sky Cell');

        // Dirty the owner record
        person.set('title', 'Master of Coin');

        ok(!address.get('isDirty'), "fragment is clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(person.get('isDirty'), "owner record is still dirty");
      });
    });

    test("rolling back the owner record returns all `DS.hasManyFragments` fragments, the fragment array, and owner record to a clean state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        // Dirty the owner record, fragment array, and a fragment
        person.set('title', 'Warden of the West');
        addresses.popObject();
        address.set('street', '2 Sky Cell');

        person.rollback();

        ok(!address.get('isDirty'), "fragment is clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("rolling back the owner record returns all `DS.hasManyFragments` primitive values, the array, and the owner record to a clean state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var titles = person.get('titles');
        var values = titles.toArray();

        // Dirty the primitive array
        titles.popObject();
        titles.unshiftObject('Giant of Lannister');

        person.rollback();

        deepEqual(values, person.get('titles').toArray(), "primitive values are reset");
        ok(!titles.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });


    test("rolling back a `DS.hasManyFragments` fragment array returns all fragments, the fragment array, and the owner record to a clean state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        // Dirty the fragment array and a fragment
        addresses.popObject();
        address.set('street', '2 Sky Cell');

        addresses.rollback();

        ok(!address.get('isDirty'), "fragment is clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("rolling back a `DS.hasManyFragments` fragment array when the owner record is dirty returns all fragments and the fragment array to a clean state and retain's the owner record's dirty state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        // Dirty the owner record, fragment array, and a fragment
        person.set('title', 'Lord of the Westerlands');
        addresses.popObject();
        address.set('street', '2 Sky Cell');

        addresses.rollback();

        ok(!address.get('isDirty'), "fragment is clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(person.get('isDirty'), "owner record is still dirty");
      });
    });

    test("rolling back a `DS.hasManyFragments` fragment returns the fragment, fragment array, and owner record to a clean states", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        // Dirty a fragment
        address.set('street', '2 Sky Cell');

        address.rollback();

        ok(!address.get('isDirty'), "fragment is clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("rolling back a `DS.hasManyFragments` fragment when the fragment array is dirty returns the fragment to a clean state and maintains the fragment array and owner record's dirty state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        // Dirty fragment array, and a fragment
        addresses.popObject();
        address.set('street', '2 Sky Cell');

        address.rollback();

        ok(!address.get('isDirty'), "fragment is clean");
        ok(addresses.get('isDirty'), "fragment array is still dirty");
        ok(person.get('isDirty'), "owner record is still dirty");
      });
    });

    test("rolling back a `DS.hasManyFragments` fragment when the owner record is dirty returns the fragment and fragment array to a clean state and maintains the owner record's dirty state", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        // Dirty the owner record, and a fragment
        person.set('title', 'Lord of Casterly Rock');
        address.set('street', '2 Sky Cell');

        address.rollback();

        ok(!address.get('isDirty'), "fragment is clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(person.get('isDirty'), "owner record is still dirty");
      });
    });

    test("a `DS.hasManyFragments` fragment property that is set to null can be rolled back", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        person.set('addresses', null);

        ok(person.get('isDirty'), "owner record is dirty");

        person.rollback();

        equal(person.get('addresses'), addresses, "property is restored");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("a `DS.hasManyFragments` fragment property that is null can be rolled back", function() {
      store.push('person', { id: 1, });

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        equal(addresses, null, "property is null");

        person.set('addresses', [
          store.createFragment('address', {
            street: "1 Spear Tower",
            city: "Sun Spear",
            region: "Dorne",
            country: "Westeros"
          })
        ]);

        ok(person.get('isDirty'), "owner record is dirty");

        person.rollback();

        equal(person.get('addresses'), null, "property is null again");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });
  }
);


define(
  "model-fragments/tests/integration/fragments/nested_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var env, store, User, Info, Order, Product;

    module("integration/fragments - Nested fragments", {
      setup: function() {
        User = DS.Model.extend({
          info   : DS.hasOneFragment("info"),
          orders : DS.hasManyFragments("order")
        });

        Info = DS.ModelFragment.extend({
          name  : DS.attr("string"),
          notes : DS.hasManyFragments()
        });

        Order = DS.ModelFragment.extend({
          amount   : DS.attr("string"),
          products : DS.hasManyFragments("product")
        });

        Product = DS.ModelFragment.extend({
          name  : DS.attr("string"),
          sku   : DS.attr("string"),
          price : DS.attr("string"),
        });

        env = setupEnv({
          user    : User,
          info    : Info,
          order   : Order,
          product : Product
        });

        store = env.store;
      },

      teardown: function() {
        env = null;
        store = null;
        User = null;
        Info = null;
        Order = null;
        Product = null;
      }
    });

    test("`DS.hasManyFragment` properties can be nested", function() {
      var data = {
        id: 1,
        info: {
          name: 'Tyrion Lannister',
          notes: [ 'smart', 'short' ]
        },
        orders: [
          {
            amount   : '799.98',
            products : [
              {
                name   : 'Tears of Lys',
                sku    : 'poison-bd-32',
                price  : '499.99'
              },
              {
                name   : 'The Strangler',
                sku    : 'poison-md-24',
                price  : '299.99'
              }
            ]
          },
          {
            amount: '10999.99',
            products: [
              {
                name  : 'Lives of Four Kings',
                sku   : 'old-book-32',
                price : '10999.99'
              }
            ]
          }
        ]
      };

      store.push('user', Ember.copy(data, true));

      env.adapter.updateRecord = function(store, type, record) {
        var payload = Ember.copy(data, true);

        payload.orders[0].products.splice(0, 1);

        return Ember.RSVP.resolve(payload);
      };

      return store.find('user', 1).then(function(user) {
        equal(user.get('orders.firstObject.products.firstObject.name'), 'Tears of Lys', "nested `DS.hasManyFragments` properties are deserialized properly");

        var product = user.get('orders.firstObject.products.firstObject');

        product.set('price', '1.99');
        ok(user.get('isDirty'), "dirty state propagates to owner");

        user.rollback();
        equal(product.get('price'), '499.99', "rollback cascades to nested fragments");
        ok(!user.get('isDirty'), "dirty state is reset");

        user.get('orders.firstObject.products').removeAt(0);
        ok(user.get('isDirty'), "dirty state propagates to owner");

        return user.save();
      }).then(function(user) {
        ok(!user.get('isDirty'), "owner record is clean");
        equal(user.get('orders.firstObject.products.length'), 1, "fragment array length is correct");
      });
    });

    test("Nested fragments fragments can have default values", function() {
      var defaultInfo = {
        notes: [ 'dangerous', 'sorry' ]
      };
      var defaultOrders = [
        {
          amount   : '1499.99',
          products : [
            {
              name  : 'Live Manticore',
              sku   : 'manticore-lv-2',
              price : '1499.99',
            }
          ]
        },
      ];

      var Assassin = DS.Model.extend({
        info   : DS.hasOneFragment("info", { defaultValue: defaultInfo }),
        orders : DS.hasManyFragments("order", { defaultValue: defaultOrders })
      });

      env.registry.register('model:assassin', Assassin);

      var user = store.createRecord('assassin');

      ok(user.get('info'), "a nested fragment is created with the default value");
      deepEqual(user.get('info.notes').toArray(), defaultInfo.notes, "a doubly nested fragment array is created with the default value");
      ok(user.get('orders.firstObject'), "a nested fragment array is created with the default value");
      equal(user.get('orders.firstObject.amount'), defaultOrders[0].amount, "a nested fragment is created with the default value");
      equal(user.get('orders.firstObject.products.firstObject.name'), defaultOrders[0].products[0].name, "a nested fragment is created with the default value");
    });
  }
);


define(
  "model-fragments/tests/integration/fragments/save_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var env, store, Person, Name, Address;

    module("integration/fragments - Persisting Records With Fragments", {
      setup: function() {
        Person = DS.Model.extend({
          name      : DS.hasOneFragment("name"),
          addresses : DS.hasManyFragments("address"),
        });

        Name = DS.ModelFragment.extend({
          first  : DS.attr("string"),
          last   : DS.attr("string")
        });

        Address = DS.ModelFragment.extend({
          street  : DS.attr("string"),
          city    : DS.attr("string"),
          region  : DS.attr("string"),
          country : DS.attr("string")
        });

        env = setupEnv({
          person  : Person,
          name    : Name,
          address : Address
        });

        store = env.store;
      },

      teardown: function() {
        env = null;
        store = null;
        Name = null;
        Person = null;
        Address = null;
      }
    });

    test("persisting the owner record in a clean state maintains clean state", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Tyrion",
          last: "Lannister"
        },
        addresses: [
          {
            street: "1 Sky Cell",
            city: "Eyre",
            region: "Vale of Arryn",
            country: "Westeros"
          }
        ]
      });

      env.adapter.updateRecord = function(store, type, record) {
        return Ember.RSVP.resolve();
      };

      return store.find('person', 1).then(function(person) {
        return person.save();
      }).then(function(person) {
        var name = person.get('name');
        var addresses = person.get('addresses');

        ok(!name.get('isDirty'), "`DS.hasOneFragment` fragment is clean");
        ok(!addresses.isAny('isDirty'), "all `DS.hasManyFragments` fragments are clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("persisting the owner record when a fragment is dirty moves owner record, fragment array, and all fragments into clean state", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Eddard",
          last: "Stark"
        },
        addresses: [
          {
            street: "1 Great Keep",
            city: "Winterfell",
            region: "North",
            country: "Westeros"
          }
        ]
      });

      env.adapter.updateRecord = function(store, type, record) {
        return Ember.RSVP.resolve();
      };

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');
        var address = person.get('addresses.firstObject');

        name.set('first', 'Arya');
        address.set('street', '1 Godswood');

        return person.save();
      }).then(function(person) {
        var name = person.get('name');
        var addresses = person.get('addresses');
        var address = addresses.get('firstObject');

        equal(name.get('first'), 'Arya', "`DS.hasOneFragment` change is persisted");
        equal(address.get('street'), '1 Godswood', "`DS.hasManyFragments` change is persisted");
        ok(!name.get('isDirty'), "`DS.hasOneFragment` fragment is clean");
        ok(!addresses.isAny('isDirty'), "all `DS.hasManyFragments` fragments are clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("persisting a new owner record moves the owner record, fragment array, and all fragments into clean state", function() {
      var payload = {
        id: 3,
        name: {
          first: "Daenerys",
          last: "Targaryen"
        },
        addresses: [
          store.createFragment('address', {
            street: "1 Stone Drum",
            city: "Dragonstone",
            region: "Crownlands",
            country: "Westeros"
          })
        ]
      };

      var person = store.createRecord('person');
      person.set('name', store.createFragment('name', payload.name));
      person.set('addresses', payload.addresses);

      env.adapter.createRecord = function(store, type, record) {
        return Ember.RSVP.resolve(payload);
      };

      return person.save().then(function(person) {
        var name = person.get('name');
        var addresses = person.get('addresses');

        ok(!name.get('isDirty'), "`DS.hasOneFragment` fragment is clean");
        ok(!addresses.isAny('isDirty'), "all `DS.hasManyFragments` fragments are clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("a new record can be persisted with null fragments", function() {
      var person = store.createRecord('person');

      equal(person.get('name'), null, "`DS.hasOneFragment` property is null");
      equal(person.get('addresses'), null, "`DS.hasManyFragments` property is null");

      env.adapter.createRecord = function(store, type, record) {
        return Ember.RSVP.resolve({ id: 1 });
      };

      return person.save().then(function(person) {
        equal(person.get('name'), null, "`DS.hasOneFragment` property is still null");
        equal(person.get('addresses'), null, "`DS.hasManyFragments` property is still null");
        ok(!person.get('isDirty'), "owner record is clean");
      });
    });

    test("the adapter can update fragments on save", function() {
      var data = {
        id: 1,
        name: {
          first: "Eddard",
          last: "Stark"
        },
        addresses: [
          {
            street: "1 Great Keep",
            city: "Winterfell",
            region: "North",
            country: "Westeros"
          }
        ]
      };

      store.push('person', data);

      env.adapter.updateRecord = function(store, type, record) {
        var payload = Ember.copy(data, true);

        payload.name.first = 'Ned';
        payload.addresses[0].street = '1 Godswood';

        return Ember.RSVP.resolve(payload);
      };

      return store.find('person', 1).then(function(person) {
        return person.save();
      }).then(function(person) {
        var name = person.get('name');
        var addresses = person.get('addresses');

        ok(!name.get('isDirty'), "`DS.hasOneFragment` fragment is clean");
        ok(!addresses.isAny('isDirty'), "all `DS.hasManyFragments` fragments are clean");
        ok(!addresses.get('isDirty'), "fragment array is clean");
        ok(!person.get('isDirty'), "owner record is clean");
        equal(name.get('first'), 'Ned', "`DS.hasOneFragment` fragment correctly updated");
        equal(addresses.get('firstObject.street'), '1 Godswood', "`DS.hasManyFragments` fragment correctly updated");
      });
    });

    test("the adapter can update fragments on reload", function() {
      var data = {
        id: 1,
        name: {
          first: "Brandon",
          last: "Stark"
        },
        addresses: [
          {
            street: "1 Great Keep",
            city: "Winterfell",
            region: "North",
            country: "Westeros"
          }
        ]
      };

      store.push('person', data);

      env.adapter.find = function(store, type, id, record) {
        var payload = Ember.copy(data, true);

        payload.name.first = 'Bran';
        payload.addresses[0].street = '1 Broken Tower';

        return Ember.RSVP.resolve(payload);
      };

      return store.find('person', 1).then(function(person) {
        // Access values that will change to prime CP cache
        person.get('name.first');
        person.get('addresses.firstObject.street');

        return person.reload();
      }).then(function(person) {
        var name = person.get('name');
        var addresses = person.get('addresses');

        equal(name.get('first'), 'Bran', "`DS.hasOneFragment` fragment correctly updated");
        equal(addresses.get('firstObject.street'), '1 Broken Tower', "`DS.hasManyFragments` fragment correctly updated");
      });
    });

    /*
      Currently in certain annoying cases in Ember, including aliases or proxies that are actively observed,
      CPs are consumed as soon as they are changed. If we are not careful, this can cause infinite loops when
      updating existing fragment data
    */
    test("the adapter can update fragments without infinite loops when CPs are eagerly consumed", function() {
      var data = {
        id: 1,
        name: {
          first: "Brandon",
          last: "Stark"
        },
        addresses: [
          {
            street: "1 Great Keep",
            city: "Winterfell",
            region: "North",
            country: "Westeros"
          }
        ]
      };

      store.push('person', data);

      return store.find('person', 1).then(function(person) {
        var personController = Ember.Controller.create({ content: person });

        Ember.addObserver(personController, 'model.name.first', function() {});
        personController.get('model.name.first');

        store.push('person', data);
        equal(person.get('name.first'), 'Brandon');
      });
    });

    test("`DS.hasManyFragments` array properties are notified on save", function() {
      expect(2);

      var data = {
        id: 1,
        name: {
          first: "Eddard",
          last: "Stark"
        },
        addresses: [
          {
            street: "1 Great Keep",
            city: "Winterfell",
            region: "North",
            country: "Westeros"
          }
        ]
      };

      var PersonProxy = Ember.ObjectProxy.extend({
        observer: function() {
          ok(true, "The array change was observed");
        }.observes('addresses.[]')
      });

      store.push('person', data);

      env.adapter.updateRecord = function(store, type, record) {
        return Ember.RSVP.resolve(data);
      };

      return store.find('person', 1).then(function(person) {
        var controller = PersonProxy.create({ content: person });
        return person.save();
      });
    });

    test("`DS.hasManyFragments` properties are notifed on reload", function() {
      expect(2);

      var Army = DS.Model.extend({
        name     : DS.attr('string'),
        soldiers : DS.hasManyFragments()
      });

      env.registry.register('model:army', Army);

      var data = {
        id: 1,
        name: "Golden Company",
        soldiers: [
          "Aegor Rivers",
          "Jon Connington",
          "Tristan Rivers"
        ]
      };

      var ArmyProxy = Ember.ObjectProxy.extend({
        observer: function() {
          equal(this.get('soldiers.length'), 2, "The array change to was observed");
        }.observes('soldiers.[]')
      });

      store.push('army', data);

      env.adapter.find = function(store, type, record) {
        var updated = Ember.copy(data, true);
        updated.soldiers.shift();

        return Ember.RSVP.resolve(updated);
      };

      return store.find('army', 1).then(function(army) {
        var proxy = ArmyProxy.create({ content: army });
        return army.reload();
      });
    });
  }
);


define(
  "model-fragments/tests/unit/fragment_array_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var env, store, Person, Name;

    module("unit/fragments - DS.FragmentArray", {
      setup: function() {
        Person = DS.Model.extend({
          names: DS.hasManyFragments("name")
        });

        Name = DS.ModelFragment.extend({
          first : DS.attr("string"),
          last  : DS.attr("string")
        });

        env = setupEnv({
          person: Person,
          name: Name
        });

        store = env.store;
      },

      teardown: function() {
        env = null;
        store = null;
        Person = null;
        Name = null;
      }
    });

    test("fragments can be created and added through the fragment array", function() {
      store.push('person', {
        id: 1,
        names: [
          {
            first: "Tyrion",
            last: "Lannister"
          }
        ]
      });

      return store.find('person', 1).then(function(person) {
        var fragments = person.get('names');
        var length = fragments.get('length');

        var fragment = fragments.createFragment({
          first: "Hugor",
          last: "Hill"
        });

        equal(fragments.get('length'), length + 1, "property size is correct");
        equal(fragments.indexOf(fragment), length, "new fragment is in correct location");
      });
    });

    test("fragments can be added to the fragment array", function() {
      store.push('person', {
        id: 1,
        names: [
          {
            first: "Tyrion",
            last: "Lannister"
          }
        ]
      });

      return store.find('person', 1).then(function(person) {
        var fragments = person.get('names');
        var length = fragments.get('length');

        var fragment = store.createFragment('name', {
          first: "Yollo"
        });

        fragments.addFragment(fragment);

        equal(fragments.get('length'), length + 1, "property size is correct");
        equal(fragments.indexOf(fragment), length, "fragment is in correct location");
      });
    });

    test("fragments can be removed from the fragment array", function() {
      store.push('person', {
        id: 1,
        names: [
          {
            first: "Arya",
            last: "Stark"
          }
        ]
      });

      return store.find('person', 1).then(function(person) {
        var fragments = person.get('names');
        var fragment = fragments.get('firstObject');
        var length = fragments.get('length');

        fragments.removeFragment(fragment);

        equal(fragments.get('length'), length - 1, "property size is correct");
        ok(!fragments.contains(fragment), "fragment is removed");
      });
    });

    test("changes to array contents change the fragment array 'isDirty' property", function() {
      store.push('person', {
        id: 1,
        names: [
          {
            first: "Aegon",
            last: "Targaryen"
          },
          {
            first: "Visenya",
            last: "Targaryen"
          }
        ]
      });

      return store.find('person', 1).then(function(person) {
        var fragments = person.get('names');
        var fragment = fragments.get('firstObject');
        var newFragment = store.createFragment('name', {
          first: 'Rhaenys',
          last: 'Targaryen'
        });

        ok(!fragments.get('isDirty'), "fragment array is initially in a clean state");

        fragments.removeFragment(fragment);

        ok(fragments.get('isDirty'), "fragment array is in dirty state after removal");

        fragments.unshiftObject(fragment);

        ok(!fragments.get('isDirty'), "fragment array is returned to clean state");

        fragments.addFragment(newFragment);

        ok(fragments.get('isDirty'), "fragment array is in dirty state after addition");

        fragments.removeFragment(newFragment);

        ok(!fragments.get('isDirty'), "fragment array is returned to clean state");

        fragments.removeFragment(fragment);
        fragments.addFragment(fragment);

        ok(fragments.get('isDirty'), "fragment array is in dirty state after reordering");

        fragments.removeFragment(fragment);
        fragments.unshiftObject(fragment);

        ok(!fragments.get('isDirty'), "fragment array is returned to clean state");
      });
    });

    test("changes to array contents change the fragment array 'isDirty' property", function() {
      store.push('person', {
        id: 1,
        names: [
          {
            first: "Jon",
            last: "Snow"
          }
        ]
      });

      return store.find('person', 1).then(function(person) {
        var fragments = person.get('names');
        var fragment = fragments.get('firstObject');

        ok(!fragments.get('isDirty'), "fragment array is initially in a clean state");

        fragment.set('last', 'Stark');

        ok(fragments.get('isDirty'), "fragment array in dirty state after change to a fragment");

        fragment.set('last', 'Snow');

        ok(!fragments.get('isDirty'), "fragment array is returned to clean state");
      });
    });

    test("changes to array contents and fragments can be rolled back", function() {
      store.push('person', {
        id: 1,
        names: [
          {
            first: "Catelyn",
            last: "Tully"
          },
          {
            first: "Catelyn",
            last: "Stark"
          }
        ]
      });

      return store.find('person', 1).then(function(person) {
        var fragments = person.get('names');
        var fragment = fragments.get('firstObject');

        var originalState = fragments.toArray();

        fragment.set('first', 'Cat');
        fragments.removeFragment(fragments.get('lastObject'));
        fragments.createFragment({
          first: 'Lady',
          last: 'Stonehart'
        });

        fragments.rollback();

        ok(!fragments.get('isDirty'), "fragment array is not dirty");
        ok(!fragments.isAny('isDirty'), "all fragments are in clean state");
        deepEqual(fragments.toArray(), originalState, "original array contents is restored");
      });
    });

    test("serializing creates a new Array with contents the result of serializing each fragment", function() {
      // TODO: this is necessary to set `typeKey` and prevent `store#serializerFor` from blowing up
      store.modelFor('person');

      var names = [
        {
          first: "Rhaegar",
          last: "Targaryen"
        },
        {
          first: "Viserys",
          last: "Targaryen"
        },
        {
          first: "Daenerys",
          last: "Targaryen"
        }
      ];

      store.push('person', {
        id: 1,
        names: names
      });

      env.registry.register('serializer:name', DS.JSONSerializer);

      return store.find('person', 1).then(function(person) {
        var serialized = person.serialize();

        deepEqual(serialized.names, names, "serializing returns array of each fragment serialized");
      });
    });
  }
);


define(
  "model-fragments/tests/unit/fragment_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var env, store, Person, Name, House;
    var all = Ember.RSVP.all;

    module("unit/fragments - DS.ModelFragment", {
      setup: function() {
        Person = DS.Model.extend({
          name: DS.hasOneFragment("name")
        });

        Name = DS.ModelFragment.extend({
          first : DS.attr("string"),
          last  : DS.attr("string")
        });

        House = DS.ModelFragment.extend({
          name   : DS.attr("string"),
          region : DS.attr("string"),
          exiled : DS.attr("boolean")
        });

        env = setupEnv({
          person: Person,
          name: Name,
          house: House
        });

        store = env.store;
      },

      teardown: function() {
        env = null;
        store = null;
        Person = null;
        Name = null;
      }
    });

    test("fragments are `Ember.Copyable`", function() {
      var fragment = store.createFragment('name');

      ok(Ember.Copyable.detect(fragment), "fragments are copyable");
    });

    test("copied fragments can be added to any record", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Jon",
          last: "Snow"
        }
      });

      store.push('person', { id: 2 });

      return all([
        store.find('person', 1),
        store.find('person', 2)
      ]).then(function(people) {
        var copy = people[0].get('name').copy();

        people[1].set('name', copy);

        ok(true, "fragment copies can be assigned to other records");
      });
    });

    test("fragments are `Ember.Comparable`", function() {
      var fragment = store.createFragment('name');

      ok(Ember.Comparable.detect(fragment), "fragments are comparable");
    });

    test("fragments are compared by reference", function() {
      var fragment1 = store.createFragment('name', {
        first: "Jon",
        last: "Arryn"
      });
      var fragment2 = store.createFragment('name', {
        first: "Jon",
        last: "Arryn"
      });

      ok(fragment1.compare(fragment1, fragment2) !== 0, "deeply equal objects are not the same");
      ok(fragment1.compare(fragment1, fragment1) === 0, "identical objects are the same");
    });

    test("changes to fragments are indicated in the owner record's `changedAttributes`", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Loras",
          last: "Tyrell"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        name.set('last', 'Baratheon');

        equal(person.changedAttributes().name, true, "changed fragments are indicated in the diff object");
      });
    });

    test("fragment properties that are set to null are indicated in the owner record's `changedAttributes`", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Rob",
          last: "Stark"
        }
      });

      return store.find('person', 1).then(function(person) {
        person.set('name', null);

        equal(person.changedAttributes().name, true, "null fragments are indicated in the diff object");
      });
    });

    test("changes to attributes can be rolled back", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Ramsay",
          last: "Snow"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        name.set('last', 'Bolton');
        name.rollback();

        ok(name.get('last', 'Snow'), "fragment properties are restored");
        ok(!name.get('isDirty'), "fragment is in clean state");
      });
    });

    test("fragment properties are serialized as normal attributes using their own serializers", function() {
      // TODO: this is necessary to set `typeKey` and prevent `store#serializerFor` from blowing up
      store.modelFor('person');

      store.push('person', {
        id: 1,
        name: {
          first: "Aerys",
          last: "Targaryen"
        }
      });

      env.registry.register('serializer:name', DS.JSONSerializer.extend({
        serialize: function() {
          return 'Mad King';
        }
      }));

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        var serialized = person.serialize();

        equal(serialized.name, 'Mad King', "serialization uses result from `fragment#serialize`");
      });
    });

    test("fragment properties are snapshotted as normal attributes on the owner record snapshot", function() {
      expect(7);

      // TODO: this is necessary to set `typeKey` and prevent `store#serializerFor` from blowing up
      store.modelFor('person');

      Person.reopen({
        houses   : DS.hasManyFragments('house'),
        children : DS.hasManyFragments()
      });

      var person = {
        id: 1,
        name: {
          first : "Catelyn",
          last  : "Stark"
        },
        houses: [
          {
            name   : "Tully",
            region : "Riverlands",
            exiled : true
          },
          {
            name   : "Stark",
            region : "North",
            exiled : true
          }
        ],
        children: [
          'Robb',
          'Sansa',
          'Arya',
          'Brandon',
          'Rickon'
        ]
      };

      store.push('person', person);

      env.registry.register('serializer:person', DS.JSONSerializer.extend({
        serialize: function(snapshot) {
          var name = snapshot.attr('name');
          ok(name instanceof DS.Snapshot, "`hasOneFragment` snapshot attribute is a snapshot");
          equal(name.attr('first'), person.name.first, "`hasOneFragment` attributes are snapshoted correctly");

          var houses = snapshot.attr('houses');
          ok(Array.isArray(houses), "`hasManyFragments` attribute is an array");
          ok(houses[0] instanceof DS.Snapshot, "`hasManyFragments` attribute is an array of snapshots");
          equal(houses[0].attr('name'), person.houses[0].name, "`hasManyFragments` attributes are snapshotted correctly");

          var children = snapshot.attr('children');
          ok(Array.isArray(children), "primitive `hasManyFragments` attribute is an array");
          deepEqual(children, person.children, "primitive `hasManyFragments` attribute is snapshotted correctly");
        }
      }));

      return store.find('person', 1).then(function(person) {
        person.serialize();
      });
    });
  }
);


define(
  "model-fragments/tests/unit/fragments/has_many_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var env, store, Person, Address, people;
    var all = Ember.RSVP.all;

    module("unit/fragments - DS.hasManyFragments", {
      setup: function() {
        Person = DS.Model.extend({
          name      : DS.attr("string"),
          addresses : DS.hasManyFragments("address"),
          titles    : DS.hasManyFragments()
        });

        Address = DS.ModelFragment.extend({
          street  : DS.attr("string"),
          city    : DS.attr("string"),
          region  : DS.attr("string"),
          country : DS.attr("string")
        });

        env = setupEnv({
          person: Person,
          address: Address
        });

        store = env.store;

        people = [
          {
            id: 1,
            name: "Tyrion Lannister",
            addresses: [
              {
                street: "1 Sky Cell",
                city: "Eyre",
                region: "Vale of Arryn",
                country: "Westeros"
              },
              {
                street: "1 Tower of the Hand",
                city: "King's Landing",
                region: "Crownlands",
                country: "Westeros"
              }
            ]
          },
          {
            id: 2,
            name: "Eddard Stark",
            addresses: [
              {
                street: "1 Great Keep",
                city: "Winterfell",
                region: "North",
                country: "Westeros"
              }
            ]
          },
          {
            id: 3,
            name: "Jojen Reed",
            addresses: null
          }
        ];
      },

      teardown: function() {
        store = null;
        Person = null;
        Address = null;
        people = null;
      }
    });

    function pushPerson(id) {
      store.push('person', Ember.copy(Ember.A(people).findBy('id', id), true));
    }

    test("properties are instances of `DS.FragmentArray`", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        ok(Ember.isArray(addresses), "property is array-like");
        ok(addresses instanceof DS.FragmentArray, "property is an instance of `DS.FragmentArray`");
      });
    });

    test("arrays of object literals are deserialized into instances of `DS.ModelFragment`", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        ok(addresses.every(function(address) {
          return address instanceof Address;
        }), "each fragment is a `DS.ModelFragment` instance");
      });
    });

    test("arrays of primitives are converted to an array-ish containing original values", function() {
      var values = [ "Hand of the King", "Master of Coin" ];

      store.push('person', {
        id: 1,
        name: {
          first: "Tyrion",
          last: "Lannister"
        },
        titles: values
      });

      return store.find('person', 1).then(function(person) {
        var titles = person.get('titles');

        ok(Ember.isArray(titles), "titles property is array-like");

        ok(titles.every(function(title, index) {
          return title === values[index];
        }), "each title matches the original value");

      });
    });


    test("fragments created through the store can be added to the fragment array", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');
        var length = addresses.get('length');

        var address = store.createFragment('address', {
          street: "1 Dungeon Cell",
          city: "King's Landing",
          region: "Crownlands",
          country: "Westeros"
        });

        addresses.addFragment(address);

        equal(addresses.get('length'), length + 1, "address property size is correct");
        equal(addresses.indexOf(address), length, "new fragment is in correct location");
      });
    });

    test("adding a non-fragment model throws an error", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        throws(function() {
          var otherPerson = store.createRecord('person');

          addresses.addFragment(otherPerson);
        }, "error is thrown when adding a DS.Model instance");
      });
    });

    test("adding fragments from other records throws an error", function() {
      pushPerson(1);
      pushPerson(2);

      return all([
        store.find('person', 1),
        store.find('person', 2)
      ]).then(function(people) {
        var address = people[0].get('addresses.firstObject');

        throws(function() {
          people[1].get('addresses').addFragment(address);
        }, "error is thrown when adding a fragment from another record");
      });
    });

    test("setting to an array of fragments is allowed", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        var addresses = person.get('addresses');

        var address = store.createFragment('address', {
          street: "1 Dungeon Cell",
          city: "King's Landing",
          region: "Crownlands",
          country: "Westeros"
        });

        person.set('addresses', [ address ]);

        equal(person.get('addresses'), addresses, "fragment array is the same object");
        equal(person.get('addresses.length'), 1, "fragment array has the correct length");
        equal(person.get('addresses.firstObject'), address, "fragment array contains the new fragment");
      });
    });

    test("null values are allowed", function() {
      pushPerson(3);

      return store.find('person', 3).then(function(person) {
        equal(person.get('addresses'), null, "property is null");
      });
    });

    test("setting to null is allowed", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        person.set('addresses', null);

        equal(person.get('addresses'), null, "property is null");
      });
    });

    test("setting to an array of non-fragments throws an error", function() {
      pushPerson(1);

      return store.find('person', 1).then(function(person) {
        throws(function() {
          person.set('addresses', [ 'address' ]);
        }, "error is thrown when setting to an array of non-fragments");
      });
    });

    test("fragments can have default values", function() {
      var defaultValue = [
        {
          street: "1 Throne Room",
          city: "King's Landing",
          region: "Crownlands",
          country: "Westeros"
        }
      ];

      var Throne = DS.Model.extend({
        name: DS.attr('string'),
        addresses: DS.hasManyFragments('address', { defaultValue: defaultValue })
      });

      env.registry.register('model:throne', Throne);

      var throne = store.createRecord('throne', { name: 'Iron' });

      equal(throne.get('addresses.firstObject.street'), defaultValue[0].street, "the default value is correct");
    });

    test("fragment default values can be functions", function() {
      var defaultValue = [
        {
          street: "1 Great Keep",
          city: "Winterfell",
          region: "North",
          country: "Westeros"
        }
      ];

      var Sword = DS.Model.extend({
        name: DS.attr('string'),
        addresses: DS.hasManyFragments('address', { defaultValue: function() { return defaultValue; } })
      });

      env.registry.register('model:sword', Sword);

      var sword = store.createRecord('sword', { name: 'Ice' });

      equal(sword.get('addresses.firstObject.street'), defaultValue[0].street, "the default value is correct");
    });
  }
);


define(
  "model-fragments/tests/unit/fragments/has_one_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var env, store, Person, Name;
    var all = Ember.RSVP.all;

    module("unit/fragments - DS.hasOneFragment", {
      setup: function() {
        Person = DS.Model.extend({
          name  : DS.hasOneFragment("name"),
          title : DS.attr('string')
        });

        Name = DS.ModelFragment.extend({
          first : DS.attr("string"),
          last  : DS.attr("string")
        });

        env = setupEnv({
          person: Person,
          name: Name
        });

        store = env.store;
      },

      teardown: function() {
        store = null;
        Person = null;
        Name = null;
      }
    });

    test("object literals are converted to instances of `DS.ModelFragment`", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Tyrion",
          last: "Lannister"
        }
      });

      return store.find('person', 1).then(function(person) {
        ok(person.get('name') instanceof Name, "name property is an `DS.ModelFragment` instance");

        equal(person.get('name.first'), 'Tyrion', "nested properties have original value");
      });
    });

    test("a fragment can be created through the store and set", function() {
      store.push('person', { id: 1 });

      return store.find('person', 1).then(function(person) {
        var name = store.createFragment('name', {
          first: "Davos",
          last: "Seaworth"
        });

        person.set('name', name);

        equal(person.get('name.first'), 'Davos', "new fragment is correctly set");
      });
    });

    test("setting to a non-fragment model throws an error", function() {
      store.push('person', { id: 1 });

      return store.find('person', 1).then(function(person) {
        throws(function() {
          person.set('name', store.createRecord('person'));
        }, "error is thrown when setting non-fragment");
      });
    });

    test("setting fragments from other records throws an error", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Roose",
          last: "Bolton"
        }
      });

      store.push('person', { id: 2 });

      return all([
        store.find('person', 1),
        store.find('person', 2)
      ]).then(function(people) {
        throws(function() {
          people[1].set('name', people[0].get('name'));
        }, "error is thrown when setting to a fragment of another record");
      });
    });

    test("null values are allowed", function() {
      store.push('person', {
        id: 1,
        name: null
      });

      return store.find('person', 1).then(function(person) {
        equal(person.get('name'), null, "property is null");
      });
    });

    test("setting to null is allowed", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Barristan",
          last: "Selmy"
        }
      });

      return store.find('person', 1).then(function(person) {
        person.set('name', null);
        equal(person.get('name'), null, "property is null");
      });
    });

    test("fragments can have default values", function() {
      var defaultValue = {
        first: "Iron",
        last: "Victory"
      };

      var Ship = DS.Model.extend({
        name: DS.hasOneFragment("name", { defaultValue: defaultValue }),
      });

      env.registry.register('model:ship', Ship);

      var ship = store.createRecord('ship');

      equal(ship.get('name.first'), defaultValue.first, "the default value is correct");
    });

    test("fragment default values can be functions", function() {
      var defaultValue = {
        first: "Oath",
        last: "Keeper"
      };

      var Sword = DS.Model.extend({
        name: DS.hasOneFragment("name", { defaultValue: function() { return defaultValue; } }),
      });

      env.registry.register('model:sword', Sword);

      var sword = store.createRecord('sword');

      equal(sword.get('name.first'), defaultValue.first, "the default value is correct");
    });
  }
);


define(
  "model-fragments/tests/unit/fragments/owner_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var store, Person, Name;
    var all = Ember.RSVP.all;

    module("unit/fragments - DS.fragmentOwner", {
      setup: function() {
        Person = DS.Model.extend({
          name: DS.hasOneFragment("name"),
        });

        Name = DS.ModelFragment.extend({
          first : DS.attr("string"),
          last  : DS.attr("string"),
          person: DS.fragmentOwner()
        });

        store = createStore({
          person: Person,
          name: Name
        });
      },

      teardown: function() {
        store = null;
        Person = null;
        Name = null;
      }
    });

    test("fragments can reference their owner record", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Samwell",
          last: "Tarly"
        }
      });

      return store.find('person', 1).then(function(person) {
        var name = person.get('name');

        equal(name.get('person'), person, "`DS.fragmentOwner` property is reference to the owner record");
      });
    });

    test("attempting to change a fragment's owner record throws an error", function() {
      store.push('person', {
        id: 1,
        name: {
          first: "Samwell",
          last: "Tarly"
        }
      });

      store.push('person', {
        id: 2,
        name: {
          first: "Samwell",
          last: "Tarly"
        }
      });

      return all([
        store.find('person', 1),
        store.find('person', 2)
      ]).then(function(people) {
        var name = people[0].get('name');

        throws(function() {
          name.set('person', people[1]);

        }, "setting the owner property throws an error");
      });
    });
  }
);


define(
  "model-fragments/tests/unit/polymorphic_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var store, Zoo, Animal, Elephant, Lion;

    module("unit/fragments - polymorphism", {
      setup: function() {
        Zoo = DS.Model.extend({
          name: DS.attr("string"),
          city: DS.attr("string"),
          star: DS.hasOneFragment("animal", { polymorphic: true, typeKey: '$type' }),
          animals: DS.hasManyFragments("animal", { polymorphic: true, typeKey: '$type', defaultValue: [] }),
        });

        Animal = DS.ModelFragment.extend({
          name: DS.attr("string"),
        });

        Elephant = Animal.extend({
          trunkLength: DS.attr("number"),
        });

        Lion = Animal.extend({
          hasManes: DS.attr("boolean"),
        });

        store = createStore({
          zoo: Zoo,
          animal: Animal,
          elephant: Elephant,
          lion: Lion,
        });

        store.push('zoo', {
          id: 1,
          name: 'Chilly Zoo',
          city: 'Winterfell',
          star: {
            $type: 'lion',
            name: 'Mittens',
            hasManes: 'true',
          },
          animals: [{
            $type: 'lion',
            name: 'Mittens',
            hasManes: 'true',
          }, {
            $type: 'elephant',
            name: 'Snuitje',
            trunkLength: 4,
          }]
        });
      },

      teardown: function() {
        store = null;
        Zoo = null;
        Animal = null;
        Elephant = null;
        Lion = null;
      }
    });

    test("hasOneFragment supports polymorphism", function() {
      return store.find('zoo', 1).then(function(zoo) {
        equal(zoo.get("name"), "Chilly Zoo", "zoo name is correct");
        equal(zoo.get("city"), "Winterfell", "zoo city is correct");

        var star = zoo.get("star");
        ok(star instanceof Animal, "zoo's star is an animal");
        equal(star.get("name"), "Mittens", "animal name is correct");
        ok(star instanceof Lion, "zoo's star is a lion");
        ok(star.get("hasManes"), "lion has manes");
      });
    });

    test("hasManyFragments supports polymorphism", function() {
      return store.find('zoo', 1).then(function(zoo) {
        var animals = zoo.get("animals");
        equal(animals.get("length"), 2);

        var first = animals.objectAt(0);
        ok(first instanceof Animal);
        equal(first.get("name"), "Mittens", "first animal's name is correct");
        ok(first instanceof Lion);
        ok(first.get("hasManes"), "lion has manes");

        var second = animals.objectAt(1);
        ok(second instanceof Animal);
        equal(second.get("name"), "Snuitje", "second animal's name is correct");
        ok(second instanceof Elephant);
        equal(second.get("trunkLength"), 4, "elephant's trunk length is correct");
      });
    });

    test("`DS.hasOneFragment` type-checks check the superclass when MODEL_FACTORY_INJECTIONS is enabled", function() {
      expect(1);

      var injectionValue = Ember.MODEL_FACTORY_INJECTIONS;
      Ember.MODEL_FACTORY_INJECTIONS = true;

      try {
        Ember.run(function () {
          var zoo = store.createRecord('zoo', { name: 'The World' });
          var animal = store.createFragment('elephant', { name: 'Mr. Pink' });

          zoo.set('star', animal);

          equal(zoo.get('star.name'), animal.get('name'), 'The type check succeeded');
        });
      } finally {
        Ember.MODEL_FACTORY_INJECTIONS = injectionValue;
      }
    });

    test("rolling back a `DS.hasOneFragment` fragment property that was set to null checks the superclass when MODEL_FACTORY_INJECTIONS is enabled", function() {
      expect(1);

      var injectionValue = Ember.MODEL_FACTORY_INJECTIONS;
      Ember.MODEL_FACTORY_INJECTIONS = true;

      return Ember.RSVP.Promise.resolve(store.find('zoo', 1)).then(function(zoo) {
        var animal = zoo.get('star');

        zoo.set('star', null);
        zoo.rollback();

        equal(zoo.get('star.name'), animal.get('name'), 'The type check succeeded');
      }).finally(function() {
        Ember.MODEL_FACTORY_INJECTIONS = injectionValue;
      });
    });

    test("`DS.hasManyFragments` type-checks check the superclass when MODEL_FACTORY_INJECTIONS is enabled", function() {
      expect(1);

      var injectionValue = Ember.MODEL_FACTORY_INJECTIONS;
      Ember.MODEL_FACTORY_INJECTIONS = true;

      try {
        Ember.run(function () {
          var zoo = store.createRecord('zoo', { name: 'The World' });
          var animal = store.createFragment('elephant', { name: 'Whitey' });

          zoo.get('animals').pushObject(animal);

          equal(zoo.get('animals.firstObject.name'), animal.get('name'), 'The type check succeeded');
        });
      } finally {
        Ember.MODEL_FACTORY_INJECTIONS = injectionValue;
      }
    });
  }
);


define(
  "model-fragments/tests/unit/store_test",
  ["exports"],
  function(__exports__) {
    "use strict";

    function __es6_export__(name, value) {
      __exports__[name] = value;
    }

    var store, Person, Name;

    module("unit/fragments - DS.Store", {
      setup: function() {
        Person = DS.Model.extend({
          name: DS.hasOneFragment("name"),
        });

        Name = DS.ModelFragment.extend({
          first : DS.attr("string"),
          last  : DS.attr("string")
        });

        store = createStore({
          person: Person,
          name: Name
        });
      },

      teardown: function() {
        store = null;
        Person = null;
        Name = null;
      }
    });

    test("a fragment can be created that starts in a dirty state", function() {
      var address = store.createFragment('name');

      ok(address instanceof Name, "fragment is correct type");
      ok(address.get('isDirty'), "fragment starts in dirty state");
    });

    test("attempting to create a fragment type that does not inherit from `DS.ModelFragment` throws an error", function() {
      throws(function() {
        store.createFragment('person');
      }, "an error is thrown when given a bad type");
    });
  }
);

//# sourceMappingURL=ember-data.model-fragments-tests.map